# 多对象池自我见解

## 一、创建一个单例的模板类Singleton

* 直接上模板：

* ```c#
  
  using UnityEngine;
  
  
  //单例模式
  public class Singleton<T> : MonoBehaviour where T : Singleton<T>
  {
      private static T instance;
  
      public static T Instance
      {
          get => instance;
      }
  
      protected virtual void Awake()
      {
          if (instance != null)//必须满足唯一性的原则
              Destroy(gameObject);
          else
              instance = (T)this;
      }
  
      protected virtual void OnDestroy()
      {
          if (instance == this)
              instance = null;
      }
  }
  
  ```

  

## 二、创建一个对象池的模板类，用于创建不同种类的对象池ObjectPool

* 多对象池的大体的框架为：T表示不同的大类，一个大类下可以有也可以有多个不同种类的对象池，比如子弹大类下可以有普通弓箭、魔法弓箭等

* 比如在子弹这个类细分的话就需要在子弹的脚本中添加一个字典，键为子弹种类，值为预制体的路径

* ```c#
  public static Dictionary<string, string> BULLETS = new Dictionary<string, string>
  {
      {"普通弓箭"， "预制体路径"}  
  };
  ```

* ==注意：对象池中会被加载的物体的预支体必须放在Resources这个文件夹中，名字必须完全一样==

* ![image-20230611224549269](https://raw.githubusercontent.com/pkxzs/PicBed/main/Img/image-20230611224549269.png)

* 

* 在开始创建对象池的模板类前，需要先创建一个接口脚本，用于管理物体从池中取出前后需要执行的函数

* 什么头函数都不需要

* ```c#
  public interface Supplement
  {
      void BeforeRecycle();
      void AfterRecycle();
      void BeforeGet();
      void AfterGet();
  }
  ```

* 开始对象池的模板类：

* 头文件不用更改

* 下面为一些参数：

* ```c#
  public class ObjectPool<T> where T : MonoBehaviour, Supplement
  {
      
      private List<T> pool;//存储对象的脚本
      public string prefab;//对象的prefab路径
      private int capacity;//目前池子的大小
      private int fillSize;//每次扩充时扩充的个数
      
  }
  ```

* 类的构造函数：

* ```c#
      public ObjectPool(string dir)
      {
          pool = new List<T>();
          prefab = dir;
          capacity = 0;
          fillSize = 5;
      }
  ```

* 对象的回收函数：

* ```c#
      public void Recycle(T target)
      {
          target.BeforeRecycle();
          pool.Add(target);
          target.gameObject.SetActive(false);
          target.AfterRecycle();
      }
  ```

* 从对象池中取出对象：

* ```c#
      public T GetItem()
      {
          if (pool.Count <= 0) return null;//检查池子中是否有闲置的对象
          T it = pool[0];
          it.BeforeGet();
          pool.RemoveAt(0);
          it.gameObject.SetActive(true);
          return it;
      }

## 三、重要的对象池的总的管理脚本PoolManager

* 该脚本继承于单例的类

* 头文件不变

* 只有一个参数：

  ```c#
  public class PoolManager : Singleton<PoolManager>
  {
      //通过字典储存不同对象的对象池，键表示对象的prefabs的路径，值表示对应的对象池
      private static Dictionary<string, object> pools;
      // Start is called before the first frame update
      void Start()
      {
          pools = new Dictionary<string, object>();
      }
  }
  ```

* 新创建一个物体，在对象池空了的情况下调用

  * ```c#
       public static GameObject CreatGameObject(string dir)
        {
            GameObject object = Resources.Load<GameObject>(dir);
            GameObject gameobject = Instantiate(object);
            gameobject.transform.position = pos; //localPosition本地位置是相对于父物体的坐标系而言的，它描述了物体在父物体坐标系中的位置偏移量。
            return gameobject;
        }
    ```

* 新创建一个对象池

  * ```c#
        public static void CreatPool<T>(ObjectPool<T> target) where T : MonoBehaviour, Supplement
        {
            pools.Add(target.prefab, target);
        }
    ```

  

* 回收函数，其他地方调用也是调用该函数

  * ```c#
        public static void Recycle<T>(T target, string prefabs) where T : MonoBehaviour, Supplement
        {
            ObjectPool<T> pool = (ObjectPool<T>)pools[prefabs];
            pool.Recycle(target);
        }
    ```

* 生成函数，从对象池中抽取对象

  ```c#
      public static T GetItem<T>(string prefabs, Vector3 pos) where T : MonoBehaviour, Supplement
      {
          if (!pools.ContainsKey(prefabs))
          {
              PoolManager.CreatPool<T>(new ObjectPool<T>(prefabs));
          }
          ObjectPool<T> pool = (ObjectPool<T>)pools[prefabs];
          T it = pool.GetItem();
          if (it == null)
          {
              GameObject gm = CreatGameObject(prefabs, pos);
          }
          it.gameObject.transform.position = pos;
          it.AfterGet();
          return it;
      }
  ```

  

## 四、在具体的类中实现接口类Supplement中的函数，比如在Bullet的类中实现

* 

* 头文件不变

  ```c#
  public class Bullet : MonoBehaviour, Supplement
  {
      public void BeforeRecycle()
      {
  
      }
  
      public void AfterRecycle()
      {
      }
  
      public void BeforeGet()
      {
  
      }
  
      public void AfterGet()
      {
          mainCamera = GameObject.FindGameObjectWithTag("MainCamera").GetComponent<Camera>();
          Vector3 mouseWorldPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
          mouseWorldPos.z = 0f;
          rec = (mouseWorldPos - transform.position).normalized;
          float angle = Mathf.Atan2(rec.y, rec.x) * Mathf.Rad2Deg;//计算角度
          transform.eulerAngles = new Vector3(0, 0, angle);
          canShot = true;
      }
  }
  ```

* 

## 五、生成函数和回收函数的调用

* 生成函数的调用：

* 参数为：预制体的路径，生成的位置

* ```c#
  PoolManager.GetItem<Bullet>(Bullet.BULLETS["弓箭"], BulletCreatPos.position);
  ```



* 回收函数的调用：

* 一般在对象本身身上，触发一定的条件调用

* 在对象本身身上时参数为this， 以及预制体路径

* ```c#
  PoolManager.Recycle<Bullet>(this, BULLETS["弓箭"]);//回收进对象池
  ```

* 
